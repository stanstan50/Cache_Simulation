
<html>
<head>
	<title>Cache Simulator</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
	<script>
		function simulate() {
		
		}

		$(document).ready(function(){
			console.log("Hello, world!");

			let MMSize = 1024; //words
			let cacheSize = 16; //blocks
			let blocksPerSet = 4; //
			let programFlow = [0, 1, 2, 3, 4]; //blocks
			let wordsPerBlock = 4;

			let cache = initializeCacheMemory(cacheSize, blocksPerSet);

			let setBits = getSetBits(blocksPerSet);
			let MMbits = getMMBitsWords(MMSize); //for MMSize is words

		//for blocks program flow
			for(let ctr = 0; ctr < programFlow.length; ctr++){
				let blockNum = programFlow[ctr];
				let numOfSets = cacheSize/blocksPerSet;

				let tagBits = getTagBits(blockNum, wordsPerBlock, blocksPerSet, MMbits);
				let setNum = getSetNumBlock(blockNum, numOfSets);

				let result = searchSet(tagBits, setNum, cache);	//checks if found

				if(result == 1){//if cache hit
					updateFoundBlock(tagBits, setNum, cache);
				} else {//if cache miss
					insertMissingBlock(tagBits, setNum, cache);
				}

			}

			// cache = [[["123", 1],["001",2],["134",4]],[["646", null],["263",1],["175",null]]];
			// insertMissingBlock("qwe",1, cache);
			// console.log(cache);

		});

		//gets cache size in blocks if user inputted words
		//Input: cache size in words, block size
		//Output: cache size in blocks
		function getCacheSize(wordsSize, wordsPerBlock){
			return wordsSize/wordsPerBlock;
		}

		//gets set number of given block in program flow
		//Input: block number, number of sets
		//Output: set number to be placed
		function getSetNumBlock(blockNum, numOfSets){
			return blockNum % numOfSets;
		}

		//gets set number of given address in program flow
		//Input: address, words per block, number of set bits, MM bits
		//Output: set number to be placed

		function getSetNumWord(address, wordsPerBlock, setBits, MMbits){
			let binaryAddress = getBinaryAddress(address, MMbits);
			let blockBits = getBlockBits(wordsPerBlock);

			let lastMMBit = MMbits - 1;
			let firstSetBit = lastMMBit - blockBits;
			let lastSetBit = firstSetBit - setBits + 1;

			let binarySetNum = binaryAddress.splice(lastSetBit, setBits);

			let setNumber = binaryToDecimal(binarySetNum, setBits);

			return setNumber;
		}

		//Initializes 2d array for cache memory
		//Input: cache size in blocks, blocksPerSet
		//Output: 2d array for cache
		function initializeCacheMemory(cacheSize, blocksPerSet){
			let cache = [];
			let numOfSets = cacheSize/blocksPerSet;

			for(let ctr = 0; ctr < numOfSets; ctr++){
				let set = [];

				for(let i = 0; i < blocksPerSet; i++){
					set.push([null, null]);
				}

				cache.push(set);
			}

			return cache;
		}
		
		//checks if the block is in the set in cache
		//Input: tag bits string, set number in cache, cache array
		//Output: 1 if found, 0 if not
		function searchSet(tagBits, setNum, cache){
			let setSize = cache[setNum].length;

			for(let ctr = 0; ctr < setSize; ctr++){
				if(cache[setNum][ctr][0] === tagBits){
					return 1;
				}
			}

			return 0;
		}

		//inserts missing block in set
		//input: tag bits string, set number in cache, cache array
		function insertMissingBlock(tagBits, setNum, cache){
			let min = cache[setNum][0][1];
			let max = 0;
			let setSize = cache[setNum].length;

			for(let ctr = 0; ctr < setSize; ctr++){
				let currentRecency = cache[setNum][ctr][1];
				if(currentRecency < min){
					min = currentRecency;
				}
				if(currentRecency > max){
					max = currentRecency;
				}
			}


			for(let ctr = 0; ctr < setSize; ctr++){
				let currentRecency = cache[setNum][ctr][1];
				if(currentRecency == min){
					cache[setNum][ctr][0] = tagBits;
					cache[setNum][ctr][1] = max + 1;
					return;
				}
			}



		}


		//recency of tag bit is incremented from max recency value in set
		//input: tagBit of found block, set number, cache array
		function updateFoundBlock(tagBits, setNum, cache){
			let setSize = cache[setNum].length;
			let max = 0;

			for(let ctr = 0; ctr < setSize; ctr++){
				let currentRecency = cache[setNum][ctr][1];
				if(currentRecency > max){
					max = currentRecency;
				}
			}

			for(let ctr = 0; ctr < setSize; ctr++){
				if(cache[setNum][ctr][0] === tagBits){
					cache[setNum][ctr][1] = max + 1;
				}
			}
		}

		//gets tag bits of given address or block in program flow
		//Input: address, words per block, number of set bits, MM bits
		//Output: tag bits in a string
		function getTagBits(address, wordsPerBlock, setBits, MMbits){
			let binaryAddress = getBinaryAddress(address, MMbits);
			let blockBits = getBlockBits(wordsPerBlock);

			let tagLength = MMbits - setBits - blockBits;

			let tagString = binaryAddress.splice(0, tagLength);
			tagString = tagString.join('');


			return tagString;
		}

		//converts binary to decimal
		//Input: binary array, num of bits
		//Output: decimal from binary
		function binaryToDecimal(binary, numOfBits){
			let decimal = 0;
			let lastBit = numOfBits - 1;

			for(let ctr = 0; ctr < numOfBits; ctr++){
				let twoPower = Math.pow(2, ctr)

				twoPower = twoPower * binary[lastBit - ctr];
				decimal = decimal + twoPower;
			}

			return decimal;
		}

		//gets binary representation of address given address and num of MM bits
		//Input: address, MMbits
		//Output: binary representation of address (in array)
		function getBinaryAddress(address, MMbits){
			let binaryAddress = [];
			let lastBit = MMbits - 1;

			for(let ctr = 0; ctr < MMbits; ctr++){
				binaryAddress.push(0);
			}

			for(let ctr = 0; ctr < MMbits; ctr++){
				let twoPower = lastBit - ctr;
				twoPower = Math.pow(2, twoPower);

				if(address >= twoPower){
					address = address - twoPower;
					binaryAddress[ctr] = 1;
				}
			}

			return binaryAddress;
		}

		//gets block bits given words per block
		//Input: words per block
		//Output: block bits
		function getBlockBits(wordsPerBlock){
			let ctr = 0;

			while(true){
				let twoPower = Math.pow(2, ctr);

				if(twoPower >= wordsPerBlock){
					return ctr;
				}

				ctr++;
			}			
		}


		//Input: number of blocks per set
		//Output: number of bits for set bits in memory address
		function getSetBits(numOfBlocks){
			let ctr = 0;

			while(true){
				let twoPower = Math.pow(2, ctr);

				if(twoPower >= numOfBlocks){
					return ctr;
				}

				ctr++;
			}
		}

		//Gets number of bits for MM (given blocks)
		//Input: number of blocks in MM, num of words per block
		//Output: number of bits for MM
		function getMMBitsBlocks(numOfBlocks, wordsPerBlock){
			let numOfWords = numOfBlocks * wordsPerBlock;
			let ctr = 0;

			while(true){
				let twoPower = Math.pow(2, ctr);

				if(twoPower >= numOfWords){
					return ctr;
				}

				ctr++;
			}
		}

		//Gets number of bits for MM (given words)
		//Input: number of words in MM
		//Output: number of bits for MM
		function getMMBitsWords(numOfWords){
			let ctr = 0;

			while(true){
				let twoPower = Math.pow(2, ctr);

				if(twoPower >= numOfWords){
					return ctr;
				}

				ctr++;
			}
		}

	</script>
	<script src="main.js"></script>
	<link rel="stylesheet" type="text/css" href="layout.css">
</head>
<body>
	<div class="body-parent">
	<div class="left-side">
		<div class="header-icon">
			<img src="cachew.png" alt="icon">
		</div>
		<div class="header-title">
			<h1>CACHE SIMULATOR</h1>
			<h2>Block Set Associative, Least Recently Used</h2>
			<hr>
		</div>
		<div class="input-area">
			<div class="input-field block">
				<label>Block Size</label>
				<input type="number" name="blocksize" min="0"/>
			</div>
			<div class="input-field set">
				<label>Set Size</label>
				<input type="number" name="setsize" min="0"/>
			</div>
			<div class="input-field mm">
				<label>MM Memory Size</label>
				<input type="number" name="setsize" min="0"/>
				<select name="mmtype">
					<option value="blocks">Blocks</option>
					<option value="words">Words</option>
				</select>
			</div>
			<div class="input-field progflow">
				<label>Program Flow</label>
				<input type="text" name="progflow"/>
				<select name="progflowtype">
					<option value="blocks">Blocks</option>
					<option value="words">Words</option>
				</select>
			</div>	
		</div>
		<div class="submitinput">
			<input type="submit" value="Simulate" onclick="simulate()"/>
		</div>
		<hr>
		<div class="simulresults">
			<div class="simulresults-header">
				<h1>SIMULATION RESULTS</h1>
			</div>
			<div class="simulresults-field">
				<p>
				Number of Cache Hits: <br>
				Number of Cache Miss: <br>
				Miss Penalty: <br>
				Average Memory Access Time: <br>
				Total Memory Access Time: <br>
				</p>
				
			</div>
		</div>
	</div>
	<div class="right-side">
		<table>
			<tr>
				<th>Set</th>
				<th>Block</th>
				<th>Data</th>
			<tr>
			<tr>
				<td rowspan="2">1</td>
				<td>1</td>
				<td></td>
			</tr>
			<tr>
				<td>2</td>
				<td></td>
			</tr>
			<tr>
				<td rowspan="2">2</td>
				<td>1</td>
				<td></td>
			</tr>
			<tr>
				<td>2</td>
				<td></td>
			</tr>
			<tr>
				<td rowspan="2">3</td>
				<td>1</td>
				<td></td>
			</tr>
			<tr>
				<td>2</td>
				<td></td>
			</tr>
		</table>
	</div>


</body>
</html>