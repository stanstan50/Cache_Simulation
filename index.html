
<html>
<head>
	<title>Cache Simulator</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
	<script>
		var blockSize = 0;
		var setSize = 0;
		var MMSize = 0;
		var MMType = "";
		var cacheSize = 0;
		var cacheType = "";
		var programFlow = "";
		var programFlowArr = null;
		var programFlowType = "";
		var isCacheSizeWord = false;
		var	isMMSizeBlock = false;
		var	isProgramFlowBlock = false;

		//parses program flow string into array
		//Input: program flow string
		//Output: program flow array of String or Number into global variable programFlowArr
		function parseProgramFlow(programFlow) {
			//blocks (block number) in decimal
			if(programFlowType == "blocks") {
				//remove any non-digit characters before and after the string
				programFlow = programFlow.replace(/\D+/g, ' ');

				//splits the string into an array of any non-digit characters
				programFlowArr = programFlow.split(/\D+/);

				//converts the array of strings into an array of numbers
				programFlowArr = programFlowArr.map(Number);
			} else { //words (addresses) in hex, considers A-F hex values
				//remove any non-digit characters before and after the string
				programFlow = programFlow.replace(/[^0-9A-Fa-f]+/g, ' ');

				//trim
				programFlow = programFlow.trim();

				//splits the string into an array of any non-hex value characters
				programFlowArr = programFlow.split(/[^0-9A-Fa-f]+/);

				//converts the array of strings into an array of strings
				programFlowArr = programFlowArr.map(String);

				//converts each string in array to uppercase
				programFlowArr = programFlowArr.map(function(x){return x.toUpperCase();});
			}
		}

		//gets user input
		function getUserInput() {
			//set all global variables to default values
			blockSize = 0;
			setSize = 0;
			MMSize = 0;
			MMType = "";
			cacheSize = 0;
			cacheType = "";
			programFlow = "";
			programFlowArr = null;
			programFlowType = "";

			// using jquery to get the value of the input fields
			blockSize = $("input[name='blocksize']").val();
			setSize = $("input[name='setsize']").val();
			MMSize = $("input[name='mmsize']").val();
			MMType = $("select[name='mmtype']").val();
			cacheSize = $("input[name='cachesize']").val();
			cacheType = $("select[name='cachetype']").val();
			programFlow = $("input[name='progflow']").val();
			programFlowType = $("select[name='progflowtype']").val();

			console.log("Block Size: " + blockSize + " words" );
			console.log("Set Size: " + setSize + " blocks");
			console.log("MM Memory Size: " + MMSize + " " + MMType);
			console.log("Cache Memory Size: " + cacheSize + " " + cacheType);
			console.log("Program Flow: " + programFlow);
			console.log("program Flow Type: " + programFlowType);

			parseProgramFlow(programFlow);
			console.log("Program Flow Array: " + programFlowArr);
			if (programFlowType == "words") { //convert strings of hex to array of decimal numbers
				programFlowArr = programFlowArr.map(function(x){return hexadeciToDeci(x);});
				console.log("Program Flow Array (Decimal): " + programFlowArr);
			}

			if (cacheType == "words") {
				isCacheSizeWord = true;
			} else {
				isCacheSizeWord = false;
			}

			if (MMType == "blocks") {
				isMMSizeBlock = true;
			} else {
				isMMSizeBlock = false;
			}

			if (programFlowType == "blocks") {
				isProgramFlowBlock = true;
			} else {
				isProgramFlowBlock = false;
			}
			
		}

		//helper function that converts hexadecimals to decimals
		function hexadeciToDeci(hex) {
			return parseInt(hex, 16);
		}

		function simulate() {
			console.log("=====================");
			console.log("Simulating...");
			console.log("=====================");
			getUserInput();
			simulateCache();
		}

		function simulateCache(){
			let MMSize = 128; //MM SIZE
			let cacheSize = 8; //CACHE SIZE
			let blocksPerSet = 2; //SET SIZE
			let programFlow = [3, 7, 12, 10, 12, 11]; //PROGRAM FLOW
			let wordsPerBlock = 8; //BLOCK SIZE

			isCacheSizeWord = false;
			isMMSizeBlock = false;
			isProgramFlowBlock = true;

			if(isCacheSizeWord == true){
				cacheSize = cacheSize/wordsPerBlock;
			}

			if(isMMSizeBlock == true){
				MMSize = wordsPerBlock * MMSize;
			}

			let cache = initializeCacheMemory(cacheSize, blocksPerSet);

			let setBits = getSetBits(blocksPerSet);
			let MMbits = getMMBitsWords(MMSize);
			let numOfSets = cacheSize/blocksPerSet;

			for(let ctr = 0; ctr < programFlow.length; ctr++){
				let current = programFlow[ctr];
				

				let tagBits = getTagBits(current, wordsPerBlock, setBits, MMbits, isProgramFlowBlock); 

				if(isProgramFlowBlock == true){
					setNum = getSetNumBlock(current, numOfSets);
				} else {
					setNum = getSetNumWord(current, numOfSets, setBits, MMbits);
				}

				let result = searchSet(tagBits, setNum, cache);


				
				if(result == 1){//if cache hit
					cache = updateFoundBlock(tagBits, setNum, cache);
				} else {//if cache miss
					cache = insertMissingBlock(tagBits, setNum, cache, setBits);
				}

			}

			console.log(cache);
			
		}

		$(document).ready(function(){
			console.log("Hello, world!");



			// let MMSize = 256; //MM SIZE
			// let cacheSize = 16; //CACHE SIZE
			// let blocksPerSet = 4; //SET SIZE
			// let programFlow = [7, 99, 201]; //PROGRAM FLOW
			// let wordsPerBlock = 4; //BLOCK SIZE

			// isCacheSizeWord = false;
			// isMMSizeBlock = false;
			// isProgramFlowBlock = false;

			let MMSize = 128; //MM SIZE
			let cacheSize = 8; //CACHE SIZE
			let blocksPerSet = 2; //SET SIZE
			let programFlow = [3, 7, 12, 10, 12, 11]; //PROGRAM FLOW
			let wordsPerBlock = 8; //BLOCK SIZE

			isCacheSizeWord = false;
			isMMSizeBlock = false;
			isProgramFlowBlock = true;

			if(isCacheSizeWord == true){
				cacheSize = cacheSize/wordsPerBlock;
			}

			if(isMMSizeBlock == true){
				MMSize = wordsPerBlock * MMSize;
			}

			let cache = initializeCacheMemory(cacheSize, blocksPerSet);

			let setBits = getSetBits(blocksPerSet);
			let MMbits = getMMBitsWords(MMSize);
			let numOfSets = cacheSize/blocksPerSet;

			for(let ctr = 0; ctr < programFlow.length; ctr++){
				let current = programFlow[ctr];
				

				let tagBits = getTagBits(current, wordsPerBlock, setBits, MMbits, isProgramFlowBlock); 

				if(isProgramFlowBlock == true){
					setNum = getSetNumBlock(current, numOfSets);
				} else {
					setNum = getSetNumWord(current, numOfSets, setBits, MMbits);
				}

				let result = searchSet(tagBits, setNum, cache);


				
				if(result == 1){//if cache hit
					cache = updateFoundBlock(tagBits, setNum, cache);
				} else {//if cache miss
					cache = insertMissingBlock(tagBits, setNum, cache, setBits);
				}

			}

			console.log(cache);

		});

		//gets cache size in blocks if user inputted words
		//Input: cache size in words, block size
		//Output: cache size in blocks
		function getCacheSize(wordsSize, wordsPerBlock){
			return wordsSize/wordsPerBlock;
		}

		//gets set number of given block in program flow
		//Input: block number, number of sets
		//Output: set number to be placed
		function getSetNumBlock(blockNum, numOfSets){
			return blockNum % numOfSets;
		}

		//gets set number of given address in program flow
		//Input: address, words per block, number of set bits, MM bits
		//Output: set number to be placed

		function getSetNumWord(address, wordsPerBlock, setBits, MMbits){
			let binaryAddress = getBinaryAddress(address, MMbits);
			let blockBits = getBlockBits(wordsPerBlock);

			let lastMMBit = MMbits - 1;
			let firstSetBit = lastMMBit - blockBits;
			let lastSetBit = firstSetBit - setBits + 1;

			let binarySetNum = binaryAddress.splice(lastSetBit, setBits);

			let setNumber = binaryToDecimal(binarySetNum, setBits);

			return setNumber;
		}

		//Initializes 2d array for cache memory
		//Input: cache size in blocks, blocksPerSet
		//Output: 2d array for cache
		function initializeCacheMemory(cacheSize, blocksPerSet){
			let cache = [];
			let numOfSets = cacheSize/blocksPerSet;


			for(let ctr = 0; ctr < numOfSets; ctr++){
				let set = [];

				for(let i = 0; i < blocksPerSet; i++){
					set.push([null, null, null]);
				}

				cache.push(set);
			}


			return cache;
		}
		
		//checks if the block is in the set in cache
		//Input: tag bits string, set number in cache, cache array
		//Output: 1 if found, 0 if not
		function searchSet(tagBits, setNum, cache){
			let setSize = cache[setNum].length;

			for(let ctr = 0; ctr < setSize; ctr++){
				if(cache[setNum][ctr][0] === tagBits){
					return 1;
				}
			}

			return 0;
		}

		//inserts missing block in set
		//input: tag bits string, set number in cache, cache array
		function insertMissingBlock(tagBits, setNum, cache, setBits){
			let min = cache[setNum][0][1];
			let max = 0;
			let setSize = cache[setNum].length;

			for(let ctr = 0; ctr < setSize; ctr++){
				let currentRecency = cache[setNum][ctr][1];
				if(currentRecency < min){
					min = currentRecency;
				}
				if(currentRecency > max){
					max = currentRecency;
				}
			}


			for(let ctr = 0; ctr < setSize; ctr++){
				let currentRecency = cache[setNum][ctr][1];
				if(currentRecency == min || currentRecency == null){
					cache[setNum][ctr][0] = tagBits;
					cache[setNum][ctr][1] = max + 1;

					cache[setNum][ctr][2] = convertTagToBlock(tagBits, setNum, setBits);
				
					return cache;
				}
			}



		}

		function convertTagToBlock(tagBits, setNum, setBits){
			let binarySet = getBinaryAddress(setNum, setBits);
			binarySet = binarySet.join("");
			let block = tagBits + binarySet;

			block = block.split('').map(Number);

			block = binaryToDecimal(block, block.length);
			return block;
		}


		//recency of tag bit is incremented from max recency value in set
		//input: tagBit of found block, set number, cache array
		function updateFoundBlock(tagBits, setNum, cache){
			let setSize = cache[setNum].length;
			let max = 0;

			for(let ctr = 0; ctr < setSize; ctr++){
				let currentRecency = cache[setNum][ctr][1];
				if(currentRecency > max){
					max = currentRecency;
				}
			}

			for(let ctr = 0; ctr < setSize; ctr++){
				if(cache[setNum][ctr][0] === tagBits){
					cache[setNum][ctr][1] = max + 1;
				}
			}

			return cache;
		}

		//gets tag bits of given address or block in program flow
		//Input: address, words per block, number of set bits, MM bits, check if block or word
		//Output: tag bits in a string
		function getTagBits(address, wordsPerBlock, setBits, MMbits, check){
			let binaryAddress = getBinaryAddress(address, MMbits);
			let blockBits = getBlockBits(wordsPerBlock);

			if(check == true){
				binaryAddress.splice(0,blockBits);
			}


			let tagLength = MMbits - setBits - blockBits;


			let tagString = binaryAddress.splice(0, tagLength);
			
			tagString = tagString.join('');

			return tagString;
		}

		//converts binary to decimal
		//Input: binary array, num of bits
		//Output: decimal from binary
		function binaryToDecimal(binary, numOfBits){
			let decimal = 0;
			let lastBit = numOfBits - 1;

			for(let ctr = 0; ctr < numOfBits; ctr++){
				let twoPower = Math.pow(2, ctr)

				twoPower = twoPower * binary[lastBit - ctr];
				decimal = decimal + twoPower;
			}

			return decimal;
		}

		//gets binary representation of address given address and num of MM bits
		//Input: address, MMbits
		//Output: binary representation of address (in array)
		function getBinaryAddress(address, MMbits){
			let binaryAddress = [];
			let lastBit = MMbits - 1;

			for(let ctr = 0; ctr < MMbits; ctr++){
				binaryAddress.push(0);
			}

			for(let ctr = 0; ctr < MMbits; ctr++){
				let twoPower = lastBit - ctr;
				twoPower = Math.pow(2, twoPower);

				if(address >= twoPower){
					address = address - twoPower;
					binaryAddress[ctr] = 1;
				}
			}

			return binaryAddress;
		}

		//gets block bits given words per block
		//Input: words per block
		//Output: block bits
		function getBlockBits(wordsPerBlock){
			let ctr = 0;

			while(true){
				let twoPower = Math.pow(2, ctr);

				if(twoPower >= wordsPerBlock){
					return ctr;
				}

				ctr++;
			}			
		}


		//Input: number of blocks per set
		//Output: number of bits for set bits in memory address
		function getSetBits(numOfBlocks){
			let ctr = 0;

			while(true){
				let twoPower = Math.pow(2, ctr);

				if(twoPower >= numOfBlocks){
					return ctr;
				}

				ctr++;
			}
		}

		//Gets number of bits for MM (given blocks)
		//Input: number of blocks in MM, num of words per block
		//Output: number of bits for MM
		function getMMBitsBlocks(numOfBlocks, wordsPerBlock){
			let numOfWords = numOfBlocks * wordsPerBlock;
			let ctr = 0;

			while(true){
				let twoPower = Math.pow(2, ctr);

				if(twoPower >= numOfWords){
					return ctr;
				}

				ctr++;
			}
		}

		//Gets number of bits for MM (given words)
		//Input: number of words in MM
		//Output: number of bits for MM
		function getMMBitsWords(numOfWords){
			let ctr = 0;

			while(true){
				let twoPower = Math.pow(2, ctr);

				if(twoPower >= numOfWords){
					return ctr;
				}

				ctr++;
			}
		}

	</script>
	<script src="main.js"></script>
	<link rel="stylesheet" type="text/css" href="layout.css">
</head>
<body>
	<div class="body-parent">
	<div class="left-side">
		<div class="header-icon">
			<img src="cachew.png" alt="icon">
		</div>
		<div class="header-title">
			<h1>CACHE SIMULATOR</h1>
			<h2>Block Set Associative, Least Recently Used</h2>
			<hr>
		</div>
		<div class="input-area">
			<div class="input-field block">
				<label>Block Size</label>
				<input type="number" name="blocksize" min="0"/>
			</div>
			<div class="input-field set">
				<label>Set Size</label>
				<input type="number" name="setsize" min="0"/>
			</div>
			<div class="input-field mm">
				<label>MM Memory Size</label>
				<input type="number" name="mmsize" min="0"/>
				<select name="mmtype">
					<option value="blocks">Blocks</option>
					<option value="words">Words</option>
				</select>
			</div>
			<div class="input-field cm">
				<label>Cache Memory Size</label>
				<input type="number" name="cachesize" min="0"/>
				<select name="cachetype">
					<option value="blocks">Blocks</option>
					<option value="words">Words</option>
				</select>
			</div>
			<div class="input-field progflow">
				<label>Program Flow</label>
				<input type="text" name="progflow"/>
				<select name="progflowtype">
					<option value="blocks">Blocks</option>
					<option value="words">Words</option>
				</select>
			</div>	
		</div>
		<div class="submitinput">
			<input type="submit" value="Simulate" onclick="simulate()"/>
		</div>
		<hr>
		<div class="simulresults">
			<div class="simulresults-header">
				<h1>SIMULATION RESULTS</h1>
			</div>
			<div class="simulresults-field">
				<p>
				Number of Cache Hits: <br>
				Number of Cache Miss: <br>
				Miss Penalty: <br>
				Average Memory Access Time: <br>
				Total Memory Access Time: <br>
				</p>
				
			</div>
		</div>
	</div>
	<div class="right-side">
		<table>
			<tr>
				<th>Set</th>
				<th>Block</th>
				<th>Data</th>
			<tr>
			<tr>
				<td rowspan="2">1</td>
				<td>1</td>
				<td></td>
			</tr>
			<tr>
				<td>2</td>
				<td></td>
			</tr>
			<tr>
				<td rowspan="2">2</td>
				<td>1</td>
				<td></td>
			</tr>
			<tr>
				<td>2</td>
				<td></td>
			</tr>
			<!--  -->
			<tr>
				<td rowspan="2">3</td>
				<td>1</td>
				<td></td>
			</tr>
			<tr>
				<td>2</td>
				<td></td>
			</tr>
			<!--  -->
		</table>
	</div>


</body>
</html>